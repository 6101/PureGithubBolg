##操作系统知识框架

### 目录
1. 启动过程
2. 函数调用过程
3. gdt
4. 中断
6. 内存和页机制
7. 线程

### 启动过程
启动过程,网上资料比较多了,大框架也有了,我就讲讲我之前不知道的几个问题,第一个是地址的计算,计算机上电之后执行的第一条命令是由 cs:ip 给出的,而这两个寄存器被初始化为FFFFF:0,按照段寻址的访址的方式得出线性地址在 FFFFF0 .
然后BIOS进行硬件自检,然后BIOS加载找到的第一个扇区512字节,放进内存 0x7c00 中,跳转该处.
512字节的前476字节被我们称为 bootloader 承担加载内核的功能,所以需要有识别功能,正常来讲应该知道文件系统和内核文件的格式.这样才知道硬盘的何处加载,以及加载到何处,和接下来跳到哪里去执行内核.
bootloader 还要需要切换到保护模式,这就需要设置好 gdt(全局地址描述表)

### gdt
gdt 是 Global Descriptor Table 的简称,用来处理保护模式下的寻址.
保护模式之所以能够实现就是因为迁移到了这种寻址方式,实模式(8086那种)是直接通过 cs 和 ip 来寻址,没有办法限制 cs 的值,也就没有办法限制一个程序访问的地址.
而保护模式就不一样了, 段寄存的值不是直接的地址,而是一个描述项的索引,描述项不仅可以给出地址,他还可以给出描述信息,规定谁可以用这段内存,cpu 在通过段寄存拿到描述信息之后,通过硬件比较描述信息,然后在计算访问内存,这就从根本上为多个程序同是运行提供了保障.
但是在操作系统的实现上, linux 绕过了这种机制(通过设置 gdt 为平坦模式,既只有一个段),改而通过页机制实现内存的分配.其实作用没差多少.

### 中断
中断是系统最重要的一环,同样是通过一张表 + 一个寄存器记录基地址来实现的.
从我的角度中断有 cpu 在执行过程发现中断, 硬件发出的中断, 我们自己写的软件发出的中断.
中断描述表(idt)主要就是绑定 中断号:中断处理函数, 当一个中断发生之后, cpu , 通过中断寄存器找到描述表地址,通过中断号找到处理函数地址,然后跳转到处理函数,处理函数保存好当前环境 -- 处理 -- 还原环境.


